---
published: true
title: 【Flask数据库】多对一、一对一关系实现
category: flask_MySQL
tags:
  - python
  - flask
  - MySQL
layout: post
---
# 一、多表同时添加数据
### 1、多对一关系同时添加实现
问题描述：以user表和article表为例，先需添加一个作者和此作者的几篇文章，需要在添加作者的同时利用外键特性也将作者的几篇文章添加进去。则可在`session.add(user)`之前先把特性绑定在要添加的`user`上，如`user.articles.append(article1)`，再`session.add(user)`。
```python
from sqlalchemy.orm import relationship
class User(Base):
    ...
    username = Column(...)
    #articles = relationship("article")

class Article(Base):
    ...
    author = relationship("User",backref = "articles")

user = User(username='zhiliao')
article1 = Article(title='abc1',content = '123')
article2 = Article(title='dedd',content='yyyy')

user.articles.append(article1)
user.articles.append(article2)
session.add(user)
session.commit()
```
### 2、一对一关系同时添加实现：
问题描述：以user表和article表为例，先需添加一篇文章和此文章的作者，需要在添加文章的同时利用外键特性也将作者添加进去。则可在`session.add(article1)`之前先把特性绑定在要添加的`article1`上，如`article1.author.append(user)`，再`session.add(article1)`。
****
# 二、一对一关系：表的扩展
问题描述：由于user表中部分栏的数据不经常需要，为节省资源，不需每次查询时都提取其中数据，因此将user表中不常用栏的数据放在扩展表中，取名为`userextend`，并与user表建立一对一关系。即userextend表中一条数据只能对应user表中的单条数据，换句话说，一个`User`对象只能对应一个`UserExtend`对象。需要在创建`relationship`对象时传入`uselist = False`实现。
```python
from sqlalchemy.orm import relationship,backref
class User(Base):
    ...
    username = Column(...)
    #extend = relationship("UserExtend",uselist = False)  

class UserExtend(Base):
    id = Column(Integer, primary_key = True, autoincrement = True)
    school = Column(String(50))
    uid = Column(Integer,ForeignKey("user.id")
    user = relationship("User",backref = backref("extend",uselist = False)) #此条使user.extend属性不再是列表，也不可同时添加多条UserExtend对象.


#因不可再使用append方法，添加单条user的同时添加绑定的userextend数据：
user =User(username = 'zhiliao')
userextend1 = UserExtend(school = 'zhiliao ketang'
user.extend = userextend1
session.add(user)
session.commit()
```
