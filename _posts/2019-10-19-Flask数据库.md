---
published: true
title: Flask数据库
category: flask_MySQL
tags:
  - python
  - flask
  - MySQL
layout: post
---
# sqlalchemy常用数据类型：
## sqlalchemy常用数据类型：

* Integer：整形(等同于INT)
*******

* Float：浮点类型（仅最多可存储32位数据，超出则丢失）
*******
* Double：双精度浮点类型（仅最多可存储64位数据，超出则丢失）
********
* Boolean: 传递True/False
*******
* DECIMAL: 定点数类型(无位数限制，可避免数据精度丢失问题)
使用需传入两个参数，第一个为总最大位数，第二个为小数点后最大位数
***********
* enum: 枚举类型
只枚举传入的变量名，如Article类下设置`tag = Column(Enum("python","flask","django"))`，则之后tag的值只能为python/flask/django。在python3中，包含enum包，通过继承enum.Enum类，可自定义枚举用类Myenum，之后只用传入`tag = Column(Enum(Myenum))`即可。
*********
* Date: 传递 datetime.date()进去
`from sqlalchemy import Date`
create_time = Column(Date)
date(年，月，日)
***********
* DateTime: 传递datetime.datetime()进去
`from sqlalchemy import Datetime`
create_time = Column(Datetime)
datetime(年，月，日[，时，分，秒，毫秒)]
*************
* Time: 传递datetime.time()进去
`from sqlalchemy import Time`
可以存储时、分、秒，time(hour=1,minute=1,second=1)
******
* String: 字符类型，使用时需要指定长度，区别于Text类型
`import...`
`title = Column(String(50))`
******
* Text: 文本类型(最多存6w多个字符)
`import...`
`title = Column(Text)`
*******
* LONGTEXT: 长文本类型(**仅MySQL拥有长文本类型**)
`from sqlalchemy.dialects.mysql import LONGTEXT`
*******
注：以上数据类型均需要在使用时从sqlalchemy库中导入。
*****
## 代码实现
===

* `Base.metadata.drop_all()`表示从数据库中删除目前绑定在Base类下的所有子类表。若数据库中本来就有其他子类表，而在此脚本中未绑定在Base下，则不会删除。再`Base.metadata.create_all()`则会把所有绑定在Base下的子类表重新在数据库中创建出来

```

#encoding: utf-8

from sqlalchemy import create_engine,Column,Integer,Float,Boolean,DECIMAL,Enum,Date,DateTime,Time,String,Text

from sqlalchemy.dialects.mysql import LONGTEXT

from sqlalchemy.ext.declarative import declarative_base

from sqlalchemy.orm import sessionmaker

# 在Python3中才有这个enum模块，在python2中没有

import enum

HOSTNAME = '127.0.0.1'

PORT = '3306'

DATABASE = 'first_sqlalchemy'

USERNAME = 'root'

PASSWORD = 'root'

# dialect+driver://username:password@host:port/database

DB_URI = "mysql+pymysql://{username}:{password}@{host}:{port}/{db}?charset=utf8mb4".format(username=USERNAME,password=PASSWORD,host=HOSTNAME,port=PORT,db=DATABASE)

engine = create_engine(DB_URI)

Base = declarative_base(engine)

session = sessionmaker(engine)()

class TagEnum(enum.Enum):

    python = "python"

    flask = "flask"

    django = "django"

class Article(Base):

    __tablename__ = 'article'

    id = Column(Integer,primary_key=True,autoincrement=True)

    # price = Column(Float)

    # is_delete = Column(Boolean)

    price = Column(DECIMAL(10,4)) #共存储10位，小数点后最多存储4位

    # 100000.0001

    # tag = Column(Enum(TagEnum))

    # create_time = Column(Date)

    # create_time = Column(DateTime)

    # create_time = Column(Time)

    # title = Column(String(50))

    # content = Column(Text)

    # content = Column(LONGTEXT)

# alembic

# flask-migrate

Base.metadata.drop_all()

Base.metadata.create_all()

from datetime import date

from datetime import datetime

from datetime import time

article = Article(price=100000.99999)

session.add(article)

session.commit()

```
# Column常用参数：

```
class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key = True,autoincrement=True)
    read_count = Column(Integer, default = 11)
    create_time = Column(Datetime, default = datetime.now)  #注，now方法不需要执行，会在提交时自动执行

Base.metadata.drop_all()
Base.metadata.create_all()

```
****
* default：默认值
如添加时不指定read_count的default默认值,则默认为null
****
* nullable: 是否为空,True/False
默认nullable为True，若`read_count = Column(Integer,nullable = False)`,则不指定read_count值时添加数据会报错。
****
* primary_key：是否为主键，True/False
****
* unique：是否唯一，True/False
默认为False，若`read_count = Column(Integer,unique= True)`,则read_count值与表内某条数据的值重复时添加数据会报错。
****
* autoincrement：是否自增长。
****
* onupdate：更新该条数据的时候自动执行
如：
`update_time = Column(DateTime,onupdate=datetime.now,default = datetime.now)`
注：在第一次创建数据的时候，不会使用onupdate的值，而会使用default值
```
article = session.query(Article).first()
article.title = 'new title'
session.commit()
```
****
* name：该属性在数据库中的字段名
当作关键字参数：
`update_time = Column(DateTime,name = '更新时间')`
或当作位置参数，在第一个位置：
`update_time = Column('更新时间',DateTime)`
# query函数可查询的数据
## query可用参数：
### 模型对象。指定查找这个模型中的所有对象
```
articles = session.query(Article).all()
for article in articles:
    print(article)#重新实现__str__方法
```
### 模型中的属性。可以指定只查找某个模型的其中几个属性。
```
articles = session.query(Article.title,Article.price).all()#返回列表，其内元素为二元元组
print(articles)#因articles是列表，重新实现__repr__方法
```
### 聚合函数
需`from sqlalchemy import func`
* func.count：统计行的数量。
`session.query(func.count(Article.id)).first()`
* func.avg：求平均值。
`session.query(func.avg(Article.price)).first()`
* func.max:求最大值。
略
* func.min：求最小值。
略
* func.sum: 求和。
*****
注：实际上，只要MySQL上有的函数，都可用func.函数名来调用。
# filter方法常用过滤条件
## 过滤条件
过滤是数据提取的重要功能，以下为filter方法实现的过滤:
******
### equals：等于
`session.query.filter(User.name == 'ed')`
*****
### not equals：不等于
`session.query.filter(User.name != 'ed')`
*****
### like：为Column的一个方法，表模糊匹配，like内传入匹配字段。
`session.query.filter(User.name.like('%ed%'))`
注：'%'为sql的通配符，匹配一个或多个字符。
        '_'仅替代一个字符。
        [abc]匹配abc中任意一个。
        [^abc]/[!abc]匹配非abc的任意字符。

注：ilike与like用法相同，但ilike不区分大小写
*****
### in_：判度胺是否存在
`session.query.filter(User.name.in_(['xushenghai','zhiliao']))`
*****
### not in:判断是否不存在
`session.query.filter(~User.name.in_(['xushenghai','zhiliao']))` #波浪表取反
或：
`session.query.filter(User.name.notin_(['xushenghai','zhiliao']))`
***
### is null:为空
先给数据库的article表添加一个空列content：
`alter table article add column content text`
再在脚本中加入content的Column对象
筛选是否为空:
`articles = session.query(Article).filter(Article.content == None).all()`
****
### is not null：不为空
`articles = session.query(Article).filter(Article.content != None).all()`
****
### and：并，可用逗号表示并,也可通过导入and_
`from sqlalchemy import and_`
`articles = session.query(Article).filter(and_(Article.content == 'abc', Article.title == 'abc')).all()`
或不用and_：
`articles = session.query(Article).filter(Article.content == 'abc', Article.title == 'abc').all()`
****
### or：或
`from sqlalchemy import or_`
`articles = session.query(Article).filter(or_(Article.content == 'abc', Article.title == 'abc')).all()`
****
## 备注
要想直接看orm底层转换的sql的命令语句，可以在filter方法后面不再调用.all()方法，直接打印结果即可。
```
articles = session.query(Article).filter(or_(Article.content == 'abc', Article.title == 'abc'))
print(articles)
```
# 外键及其四种约束
## 外键
通过ForeignKey类来实现，并且可以指定表的外键约束。
******
以下为user表为父表，article表为子表，通过user.id连接。
```python
class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title = Column(String(50),nullable=False)
    content = Column(Text,nullable=False)
    uid = Column(Integer,ForeignKey('user.id')) #此处数据类型应与父表的id的数据类型相同

    def __repr__(self):
        return "<Article(title:%s)>" % self.title

class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(50),nullable=False)
```
****
### 外键约束种类：
#### RESTRICT：父表数据被删除，会阻止删除。默认就是这一项。
#### NO ACTION：在MySQL中，同RESTRICT。
#### CASCADE：级联删除。即父表数据被删除，子表也被删除。
#### SET NULL：父表数据被删除，子表数据会设置为NULL。
*****
### 选定外键约束的种类，通过设定关键字ondelete的值实现：
`uid = Column(Integer,ForeignKey('user.id',ondelete="RESTRICT"))`
则在mysql中输入`delete from user where id = 1;`会报错
# ORM层外键访问方式和一对多
## 一对多外键关系
通过sqlalchemy.orm下的relationship实现
如一个作者可以有多篇文章，此为一对多关系。以下为通过文章找作者和通过作者找文章的例子：
## 代码实现
```python
from sqlalchemy.orm import relationship
class User(Base):
    ...
    username = Column(...)
    articles = relationship("article")

class Article(Base):
    ...
    author = relationship("User")
#用relationship，通过article表数据取user表对应id的数据
article = session.query(Article).first()
print(article.author.username)
#用relationship，通过user表数据取article表对应id的数据
user = session.query(User).first()
print(user.articles)
```
反向引用可使relationship成双向关系，使用反向引用则不需要在每个类后面设定relationship。
```
from sqlalchemy.orm import relationship
class User(Base):
    ...
    username = Column(...)

class Article(Base):
    ...
    author = relationship("User",beckref = "articles")
```
# 多对一、一对一关系实现
## 多表同时添加数据
### 多对一关系同时添加实现
问题描述：以user表和article表为例，先需添加一个作者和此作者的几篇文章，需要在添加作者的同时利用外键特性也将作者的几篇文章添加进去。则可在`session.add(user)`之前先把特性绑定在要添加的`user`上，如`user.articles.append(article1)`，再`session.add(user)`。
```python
from sqlalchemy.orm import relationship
class User(Base):
    ...
    username = Column(...)
    #articles = relationship("article")

class Article(Base):
    ...
    author = relationship("User",backref = "articles")

user = User(username='zhiliao')
article1 = Article(title='abc1',content = '123')
article2 = Article(title='dedd',content='yyyy')

user.articles.append(article1)
user.articles.append(article2)
session.add(user)
session.commit()
```
### 一对一关系同时添加实现：
问题描述：以user表和article表为例，先需添加一篇文章和此文章的作者，需要在添加文章的同时利用外键特性也将作者添加进去。则可在`session.add(article1)`之前先把特性绑定在要添加的`article1`上，如`article1.author.append(user)`，再`session.add(article1)`。
****
## 一对一关系：表的扩展
问题描述：由于user表中部分栏的数据不经常需要，为节省资源，不需每次查询时都提取其中数据，因此将user表中不常用栏的数据放在扩展表中，取名为`userextend`，并与user表建立一对一关系。即userextend表中一条数据只能对应user表中的单条数据，换句话说，一个`User`对象只能对应一个`UserExtend`对象。需要在创建`relationship`对象时传入`uselist = False`实现。
```python
from sqlalchemy.orm import relationship,backref
class User(Base):
    ...
    username = Column(...)
    #extend = relationship("UserExtend",uselist = False)  

class UserExtend(Base):
    id = Column(Integer, primary_key = True, autoincrement = True)
    school = Column(String(50))
    uid = Column(Integer,ForeignKey("user.id")
    user = relationship("User",backref = backref("extend",uselist = False)) #此条使user.extend属性不再是列表，也不可同时添加多条UserExtend对象.
#因不可再使用append方法，添加单条user的同时添加绑定的userextend数据：
user =User(username = 'zhiliao')
userextend1 = UserExtend(school = 'zhiliao ketang'
user.extend = userextend1
session.add(user)
session.commit()
```

# 多对多关系实现
## 多对多关系
问题说明：一篇文章可以有多个标签，一个标签下也可以有多个文章。
解决方法：构件一张中间表，以存储他们的对应关系。
`from sqlalchemy import Table`
创建一个Table对象并在Article类或Tag类内建立relationship时传入secondary = Table对象。
即：`article_tag =Table(...)`,
`tags = relationship("Tag",backref="articles",secondary = article_tag )`
## 代码实现
```python
from sqlalchemy import Table
article_tag = Table("article_tag",#指定表名
    #在创建表时指定用Base.metadata创建
    Base.metadata,
    #创建名为"article_id"的列，一头连接article.id
    Column("article_id",Integer,ForeignKey("article.id"),primary_key = True),
    #创建名为"tag_id"的列，一头连接tag.id，并且也设置为主键，从而与article_id组成复合主键，复合主键会组合查重，如1-1与1-1重复，而1-1与1-2不重复。这就避免了数据重复问题。
    Column("tag_id",Integer,ForeignKey("tag.id"),primary_key = True)
)


class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title = Column(String(50),nullable=False)
    #tags = relationship("tag",backref="articles",secondary = article_tag )

    def __repr__(self):
        return "<Article(title:%s)>" % self.title

class Tag(Base):
    __tablename__ = 'tag'
    id = Column(Integer,primary_key=True,autoincrement=True)
    name= Column(String(50),nullable=False)
    articles = relationship("Article",backref="tags",secondary = article_tag)

    def __repr__(self):
        return "<Tag(title:%s)>" % self.title

#添加数据
article1 = Article(title="title1")
article2 = Article(title="title2")

tag1 = Tag(name="tag1")
tag2 = Tag(name="tag2")

article1.tags.append(tag1)
article1.tags.append(tag2)

article2.tags.append(tag1)
article2.tags.append(tag2)

session.add_all(article1,article2)
session.commit()

#查询数据
article = session.query(Article).first()
print(article.tags)
```
# ORM层面删除数据注意事项
尽管MySQL默认约束类型为RESTRIC，但若不设置从表中关联列的nullable=False，那么通过sqlalchemy的ORM删除数据不会报错！！
```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username= Column(String(50),nullable=False)
    articles = relationship("Article",backref="tags")

    def __repr__(self):
        return "<Tag(title:%s)>" % self.title

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title= Column(String(50),nullable=False)
    uid = Column(Integer,ForeignKey("User.id"))
    author = relationship("User",backref = "articles")

    def __repr__(self):
        return "<Article(title:%s)>" % self.title

Base.metadata.drop_all()
Base.metadata.create_all()
#添加一条数据
user = User(username='zhiliao')
article = Article(title='hello world')
article.author = user
session.add(article)
session.commit()
#尽管MySQL默认约束类型为RESTRIC，但用sqlalchemy的ORM删除数据不会报错！！实际步骤为：检测到有外键关联，但发现外键类型为RESTRICT，因此先通过外键找到关联的数据，将关联的uid设置为null，之后再删除user。
user = session.query(User).first()
session.delete(user)
session.commit()
#要防止误删时RESTRICT没用，应该在创建外键时设置nullable=False。
class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title= Column(String(50),nullable=False)
    uid = Column(Integer,ForeignKey("User.id"),nullable=False)
    author = relationship("User",backref = "articles")

```
# relationship方法中的cascade参数详解(1-2)
## ORM层面的CASCADE
在SALAlchemy中，只要将一条数据添加到session中，和他相关联的数据都可以一起存入。这其实是通过relationship对象创建时传入关键字参数cascade实现的，另外，也可在backref中传入casecade关键字：
### `save-update`:
默认选项，自动把其他关联数据添加到数据库中就是这条实现的。若不想同步添加，令`cascade=''`
### `delete`：
表示当删除某一个模型中的数据的时候，是否也删掉使用`relationship`和他关联的数据。
### `delete-orphan`：
表示当对一个ORM对象解除了父表中的关联对象的时候，自己便会被删除掉(即子表中的某条数据没有了关联数据，则该条数据会被自动删除掉)。当然如果父表中的数据被删除，自己也会被删除。这个选项只能用在一对多上，不能用在多对多以及多对一上。并且还需要在子模型中的`relationship`中，增加一个`single_parent=True`的参数。
### `merge`：
默认选项。当在使用`session.merge`，合并一个对象的时候，会将使用了`relationship`相关联的对象也进行`merge`操作。如user表中已有一条数据id=1，而脚本中另外生成了一条id=1的数据，那么就可用merge覆盖掉原数据及相关联数据。实际项目使用较少。
### `expunge`：
移除操作的时候，会将相关联的对象也进行移除。这个操作与session.delete(obj)不同，它只是从`session`中移除，并等到`session.commit()`时不会真正的从数据库中删除。实际项目使用较少。
### `all`：
是对`save-update, merge, refresh-expire(极少用), expunge, delete`几种的缩写。
************
## save-update及delete例子

```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username= Column(String(50),nullable=False)

    def __repr__(self):
        return "<Tag(title:%s)>" % self.title

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title= Column(String(50),nullable=False)
    uid = Column(Integer,ForeignKey("User.id"))
    author = relationship("User",backref = backref("articles",cascade="save-update,delete"),cascade="save-update")
    #author = relationship("User",backref = "articles"，cascade="save-update,delete")，删除article数据时也会删除user数据


    def __repr__(self):
        return "<Article(title:%s)>" % self.title
############################
Base.metadata.drop_all()
Base.metadata.create_all()

user = User(username="zhiliao")
article = Article(title = "article1")
article.author= user
session.add(article)#cascade=''，所以不会添加article的user属性，即uid
session.commit()
############################
Base.metadata.drop_all()
Base.metadata.create_all()

user = User(username="zhiliao")
article = Article(title = "article1")
article.author= user
session.add(article)#cascade=''，所以不会添加article的user属性，即uid
session.commit()
```
### delete-orphan
```
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username= Column(String(50),nullable=False)

    def __repr__(self):
        return "<Tag(title:%s)>" % self.title

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title= Column(String(50),nullable=False)
    uid = Column(Integer,ForeignKey("User.id"))
    author = relationship("User",backref = backref("articles",cascade="save-update,delete,delete-orphan"),cascade="save-update",single_parent = True)

    def __repr__(self):
        return "<Article(title:%s)>" % self.title

```
### merge合并操作及expunge移除操作因不常用，略。
# 三种排序方式详解
## 三种排序方法
### order_by
可以指定根据这个表中的某个字段进行排序，如果在前面加了一个‘-’，代表的是降序排序。正序排序为由小到大，倒序排序为由大到小。若针对时间排序，在倒序(从新往旧)排序时需调用desc()方法，或加负号。
```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username= Column(String(50),nullable=False)
    create_time = Column(DateTime,nullable=False,default=datetime.now)

articles = session.query(Article).order_by(Article.create_time.desc()).all()
#或
articles = session.query(Article).order_by("-create_time").all()

print(articles)
```
### 在模型定义的时候指定默认排序
有些时候，不想每次在查询的时候都指定排序的方式，可以在定义模型的时候就指定排序的方式。
有以下两种定义排序方式：

#### relationship的order_by参数
在指定relationship的时候，传递order_by参数来指定排序的字段。
```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username= Column(String(50),nullable=False)
    create_time = Column(DateTime,nullable=False,default=datetime.now)

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title= Column(String(50),nullable=False)
    create_time = Column(DateTime,nullable=False,default=datetime.now)
    uid = Column(Integer,ForeignKey = "user.id"
    user = relationship("User",backref=backref("articles",order_by="-create_time")
```
#### 在模型定义中
添加以下代码：
```python
 __mapper_args__ = {
     "order_by": title
   }
```
或：
```
 __mapper_args__ = {
     "order_by": title.desc()
   }
```
即可让文章使用标题来进行排序。

### 正向排序和反向排序
默认情况是从小到大，从前到后排序的，如果想要反向排序，可以调用排序的字段的desc方法。
# limit、offset以及切片操作
## limit：可以限制每次查询的时候只查询几条数据。
```python
class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title = Column(String(50),nullable=False)
    create_time = Column(DateTime,default=datetime.now)

articles = session.query(Article).limit(10).all()
```
## offset：可以限制查找数据的时候过滤掉前面多少条。
```python
articles = session.query(Article).order_by(Article.id.desc()).offset(10).limit(10).all() #从第二十篇开始，往前找10篇
```
## slice切片：可以对Query对象使用切片操作，来获取想要的数据。      
1)`slice(self,start,stop)`start从0开始，含，stop不含。
```python
articles = session.query(Article).order_by(Article.id.desc()).slice(0,10).all()
```
2)**[  ]:常用方法**
```python
articles = session.query(Article).order_by(Article.id.desc())[0:10]
```
# 数据查询懒加载技术
## 懒加载
在一对多，或者多对多的时候，如果想要获取多的这一部分的数据的时候，往往能通过一个属性就可以全部获取了。比如有一个作者，想要或者这个作者的所有文章，那么可以通过user.articles就可以获取所有的。但有时候我们不想获取所有的数据，比如只想获取这个作者今天发表的文章，那么这时候我们可以给relationship传递一个lazy='dynamic'，以后通过user.articles获取到的就不是一个列表，而是一个AppendQuery对象了。这样就可以对这个对象再进行一层过滤和排序等操作。
******
## lazy可用选项
### 'select'：默认选项，如果不使用访问对象的某些属性，则不会提取那些属性，如user.articles，在不使用时就不会访问，一旦使用则提取该属性的全部内容并组装成一个列表。
### 'dynamic'：访问'user.articles'不是返回一个列表，而是`AppenderQuery`对象。
### `immediate`：立刻提取访问对象并提取它的相关属性。
## 代码实现
```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key = True,autoincrement = True)
    username = Column(String(50),nullable = False)

class Article(Base):
    __tablename__ = article
    id = Column(Integer,primary_key = True,autoincrement = True)
    title = Column(String(50),nullable = False)
    create_time = Column(DateTime,default = datetime.now)
    uid = Column(Integer,ForeignKey("user.id"))

    autho = relationship("User",backref=backref("articles",lazy = 'dynamic')

user  = session.query(User).first()
#因为使用了lazy='dynamic'，所以user为AppenderQuery对象，可继续追加数据进去。
article = Article(title="title 101")
user.articles.append(article)
session.commit()
```
# group_by和having子句
## group_by
根据某个字段进行分组。比如想要根据性别进行分组，来统计每个分组分别有多少人，那么可以使用以下代码来完成：
```
session.query(User.gender,func.count(User.id)).group_by(User.gender).all()
```
## having
having是对查找结果进一步过滤。比如只想要看未成年人的数量，那么可以首先对年龄进行分组统计人数，然后再对分组进行having过滤。示例代码如下：
```
result = session.query(User.age,func.count(User.id)).group_by(User.age).having(User.age >= 18).all()
```
# join实现复杂查询
## join方法：
join查询分为两种，一种是inner join，另一种是outer join。默认的是inner join，如果指定left join或者是right join则为outer join。
### 内连接：inner join
两张被内连接的表主键不匹配时，不匹配的数据均被抛弃。
### 外连接：left join
是以左表为基准，连接过程中右表不匹配项会被设置为null，左表数据保留；right join是以右表为基准，连接过程中左表不匹配项会被设置为null，右表数据保留。
#### 通过原生sql语句实现：
```python
select user.username,count(article.id) from user join article on user.id = article.uid group by user.id order by count(article.id) desc;
从join后的user与article中提取数据，显示不同user的article数量并以降序的方式排列出来。
```
#### 如果想要查询User及其对应的Article，则可以通过以下方式来实现(默认join为内连接)：
```python
result = session.query(User.username,func.count(Article.id)).join(Article,User.id == Article.uid).group_by(User.id).order_by(func.count(Article.id)).desc()
```
这是通过普通方式的实现，也可以通过join的方式实现，更加简单：
```python
  for u,a in session.query(User,Address).join(Address).all():
    print u
    print a
  # 输出结果：
  >>> <User (id=1,name='ed',fullname='Ed Jason',password='123456')>
  >>> <Address id=4,email=ed@google.com,user_id=1>
```
当然，如果采用outerjoin，可以获取所有user，而不用在乎这个user是否有address对象，并且outerjoin默认为左外查询：
```python
  for instance in session.query(User,Article).outerjoin(Article).all():
    print instance
  # 输出结果：
  (<User (id=1,name='ed')>, <Article id=4,email=ed@google.com,user_id=1>)
  (<User (id=2,name='xt')>, None)
```
# subquery实现复杂查询
```python
class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key = True,autoincrement=True)
    username = Column(String(50),nullable=False)
    city = Column(String(50),nullable=False)
    age = Column(Integer,default = 0)

    def __repr__(self):
        return "<User(username:  %s)>"% self.username

Base.metadata.drop_all()
Base.metadata.create_all()

user1 = User(username="A",city="changsha",age=18)
user2 = User(username="B",city="changsha",age=18)
user3 = User(username="C",city="beijing",age=18)
user4 = User(username="D",city="changsha",age=20)

session.add_all([user1,user2,user3,user4])
session.commit()
```
需求：寻找和A在同一个城市并且是同年龄的人。
## query传统方式分两次查找
```python
user = session.query(User).filter(User.username = "A").first()
users = session.query(User).filter(User.city == user.city,User.age = user.age).all()
```
## sql原生传统方式子查找
```python
select user.id,user.username,user.city,user.age from user,(select user.city,user.age from user where user.username="A") as li_a where user.age = li_a.age and user.city=li_a.city
```
## query子查寻方式：
```python
stmt = session.query(User.city.lable("city"),User.age.lable("age")).filter(User.username=="A").subquery()
session.query(User).filter(User.city ==stmt.c.city,User.age==stmt.c.age).all()
```
调用`subquery()`方法后会返回子查询对象，用lable生成对应属性的别名方便以后调用(`age`和`city`属性)，用`stmt`变量接收后，可以调用`.c`方法，`c`代表`Column`列，`stmt.c.city`返回子查询对象的city值。
# `Flask-SQLAlchemy`插件的使用
## `Flask-SQLAlchemy`插件
功能为将创建引擎部分做成插件，供flask使用，以连接数据库。
* 用`db.Model`作为基类创建类表。
* `Column\Integer\String\relationship`不再需要导入，用`db.Column`形式就可以。
* 在定义模型的时候。可以不写`__tablename__`，则`Flask-SQLAlchemy`会自动将表名设为类名的小写。驼峰命名的类则会转为小写后用下划线连接，如`UserModel`转为`user_model`。明言胜于暗语，此条功能不用为好！！！
* 如果只是查找一个表上的数据，可以通过`表名.query`方法查询。如
`users = User.query.order_by(User.id.desc())all()`

## `Flask-SQLAlchemy`插件安装
`pip install flask-sqlalchemy`
```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

HOSTNAME = '127.0.0.1'
PORT = '3306'
DATABASE = 'flask_sqlalchemy_demo'
USERNAME = 'root'
PASSWORD = 'root'
# dialect+driver://username:password@host:port/database
DB_URI = "mysql+pymysql://{username}:{password}@{host}:{port}/{db}?charset=utf8mb4".format(username=USERNAME,password=PASSWORD,host=HOSTNAME,port=PORT,db=DATABASE)

app.config['SQLALCHEMY_DATABASE_URL'] = DB_URI
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

class User(db.Model):
    #flask-sqlalchemy插件会默认动将表名设为类名的小写，此行可以省略。
    #__tablename__ = 'user'
    #若类名为驼峰命名模式，则改成小写后用下划线连接：如UserModel表名默认为user_model。
    #一般不省略指定表名！！！

    id = db.Column(db.Integer,primary_key = True,autoincrement = True)
    username = db.Column(db.String(50),nullable = False)

    def __repr__(self):
        return 'User(username: %s)'%self.username

class Article(db.Model):
    id = db.Column(db.Integer,primary_key =True,autoincrement = True)
    title = db.Column(db.String(50),nullalble=False)
    uid = db.Column(db.Integer,db.ForeignKey("user.id"))

    author = db.relationship("User",backref="articles")

db.drop_all()
db.create_all()

#添加数据
user = User(username="user1")
article = Article(title="title1")
article.author = user

db.session.add(article)
db.session.commit()

#查询数据
#group_by
#order_by
#filter
#join
users = User.query.all()
article = Article.query.order_by(User.id.desc()).all()
print(users)

#删除、修改
user = User.query.filter(User.username == 'zhiliao').first()
user.username = 'zhiliao1'
db.session.commit()
db.session.delete(user)
db.session.commit()

@app.route('/')
def hello_world():
    return "Hello World!"

if __name__ == "__main__":
    app.run()
```
